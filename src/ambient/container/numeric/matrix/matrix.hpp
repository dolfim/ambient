/*
 * Copyright Institute for Theoretical Physics, ETH Zurich 2014.
 * Distributed under the Boost Software License, Version 1.0.
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef AMBIENT_CONTAINER_NUMERIC_MATRIX_HPP
#define AMBIENT_CONTAINER_NUMERIC_MATRIX_HPP

#include "ambient/container/numeric/matrix/matrix.h"
#include "ambient/container/numeric/matrix/matrix_algorithms.hpp"

namespace ambient { namespace numeric {

    // {{{ transpose_view

    template <class Matrix>
    inline transpose_view<Matrix>& transpose_view<Matrix>::locate(size_type i, size_type j){
        return *this;
    }

    template <class Matrix>
    inline const transpose_view<Matrix>& transpose_view<Matrix>::locate(size_type i, size_type j) const {
        return *this;
    }

    template <class Matrix>
    inline size_t transpose_view<Matrix>::addr(size_type i, size_type j) const {
        return (j + i*this->lda()); 
    }

    template <class Matrix>
    transpose_view<Matrix>::operator Matrix () const {
        Matrix t(*(Matrix*)this);
        transpose_inplace(t); 
        return t;
    }

    template <class Matrix>
    inline size_t transpose_view<Matrix>::num_rows() const {
        return ((Matrix*)this)->num_cols();
    }

    template <class Matrix>
    inline size_t transpose_view<Matrix>::num_cols() const {
        return ((Matrix*)this)->num_rows();
    }

    template<class Matrix>
    template<class M> 
    size_t transpose_view<Matrix>::inc(const M& a){ 
        return a.num_rows(); 
    } 

    template<class Matrix>
    template<class M> 
    size_t transpose_view<Matrix>::rows(const M& a){ 
        return a.num_cols(); 
    } 

    template<class Matrix>
    template<class M> 
    size_t transpose_view<Matrix>::cols(const M& a){ 
        return a.num_rows(); 
    } 

    template<class Matrix>
    const char* transpose_view<Matrix>::code(){
        return "T"; 
    }  

    // }}}
    // {{{ subset_view

    template<class Matrix>
    template<class M> 
    size_t subset_view<Matrix>::rows(const M& a){ 
        return ((Matrix&)a).num_rows(); 
    } 

    template<class Matrix>
    template<class M> 
    size_t subset_view<Matrix>::cols(const M& a){ 
        return ((Matrix&)a).num_cols(); 
    } 

    template<class Matrix>
    const char* subset_view<Matrix>::code(){
        return "N"; 
    }  
    
    // }}}
    // {{{ matrix
    #define size_type   typename matrix<T,A>::size_type
    #define value_type  typename matrix<T,A>::value_type
    #define scalar_type typename matrix<T,A>::scalar_type

    template <typename T, class A>
    inline matrix<T,A>::matrix(){ 
    }

    template <typename T, class A>
    inline matrix<T,A>::matrix(size_type rows, size_type cols, value_type init_value) : ambient::block<T>(rows, cols) {
        fill_value(*this, init_value);
    }

    template <typename T, class A>
    inline matrix<T,A>::matrix(const matrix& a) : ambient::block<T>(a.num_rows(), a.num_cols()) {
        ambient::merge(a, *this);
    }
    
    template <typename T, class A>
    matrix<T,A>& matrix<T,A>::operator = (const matrix& rhs){
        matrix c(rhs);
        this->swap(c);
        return *this;
    }

    template <typename T, class A>
    template <class OtherAllocator>
    matrix<T,A>& matrix<T,A>::operator = (const matrix<T,OtherAllocator>& rhs){
        this->resize(rhs.num_rows(), rhs.num_cols());
        ambient::numeric::copy_block(rhs, 0, 0, *this, 0, 0, // not optimal
                                     num_rows(), num_cols());
        return *this;
    }

    template<typename T, class A>
    template<class M> 
    size_t matrix<T,A>::inc(const M& a){ 
        return 1; 
    }

    template<typename T, class A>
    template<class M> 
    size_t matrix<T,A>::rows(const M& a){ 
        return a.num_rows(); 
    }

    template<typename T, class A>
    template<class M> 
    size_t matrix<T,A>::cols(const M& a){ 
        return a.num_cols(); 
    }

    template<typename T, class A>
    inline size_type matrix<T,A>::num_rows() const { 
        return ambient::get_dim(*this).y; 
    }

    template<typename T, class A>
    inline size_type matrix<T,A>::num_cols() const {
        return ambient::get_dim(*this).x; 
    }

    template<typename T, class A>
    inline scalar_type matrix<T,A>::trace() const { 
        return trace(*this);           
    }

    template<typename T, class A>
    inline void matrix<T,A>::transpose(){ 
        transpose_inplace(*this);      
    }

    template<typename T, class A>
    inline void matrix<T,A>::conj(){ 
        conj_inplace(*this);           
    }

    template<typename T, class A>
    inline void matrix<T,A>::swap(matrix& r){ 
        ambient::swap_with(*this, r);
    }

    template<typename T, class A>
    inline void matrix<T,A>::resize(size_type m, size_type n){
        ambient::numeric::resize(*this, m, n);
    }

    template<typename T, class A>
    inline matrix<T,A>& matrix<T,A>::locate(size_type i, size_type j){
        return *this;
    }

    template<typename T, class A>
    inline const matrix<T,A>& matrix<T,A>::locate(size_type i, size_type j) const {
        return *this;
    }

    template<typename T, class A>
    inline size_t matrix<T,A>::addr(size_type i, size_type j) const {
        return (i + j*this->lda());
    }

    template<typename T, class A>
    inline matrix<T,A>& matrix<T,A>::operator += (const matrix& rhs){
        add_inplace(*this, rhs);
        return *this;
    }

    template<typename T, class A>
    inline matrix<T,A>& matrix<T,A>::operator -= (const matrix& rhs){
        sub_inplace(*this, rhs);
        return *this;
    }

    template<typename T, class A>
    template <typename T2> 
    inline matrix<T,A>& matrix<T,A>::operator *= (const T2& t){
        mul_inplace(*this, t);
        return *this;
    }

    template<typename T, class A>
    template <typename T2> 
    inline matrix<T,A>& matrix<T,A>::operator /= (const T2& t){
        div_inplace(*this, t);
        return *this;
    }

    template<typename T, class A>
    inline value_type& matrix<T,A>::operator()(size_type i, size_type j){
        return ambient::block<T>::operator()(i,j);
    }

    template<typename T, class A>
    inline const value_type& matrix<T,A>::operator()(size_type i, size_type j) const {
        return ambient::block<T>::operator()(i,j);
    }

    template<typename T, class A>
    inline value_type* matrix<T,A>::data(){
        return ambient::block<T>::data();
    }

    template<typename T, class A>
    inline const value_type* matrix<T,A>::data() const {
        return ambient::block<T>::data();
    }

    template<typename T, class A>
    const char* matrix<T,A>::code(){ 
        return "N"; 
    }

    #undef size_type
    #undef value_type
    #undef scalar_type
    // }}}

} }

#endif
