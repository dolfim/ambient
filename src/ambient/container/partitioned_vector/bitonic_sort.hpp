/*
 * Copyright Institute for Theoretical Physics, ETH Zurich 2014.
 * Distributed under the Boost Software License, Version 1.0.
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef AMBIENT_CONTAINER_PARTITIONED_VECTOR_BITONIC_SORT_HPP
#define AMBIENT_CONTAINER_PARTITIONED_VECTOR_BITONIC_SORT_HPP

namespace ambient { namespace detail {

    template<class InputIterator, class Compare>
    class bitonic_sort_inblock {
    public:
        static void compare(InputIterator first, InputIterator last, InputIterator end, Compare comp){
            int dist = (last-first)/2;
            InputIterator middle = first+dist;
            if(middle > end) return;

            int max = end - middle;
            for(int i = 0; i < max; ++i)
                if(!comp(*(first+i), *(middle+i)))
                    std::swap(*(first+i), *(middle+i));
        }
        static void compare_crossover(InputIterator first, InputIterator last, InputIterator end, Compare comp){
            int dist = (last-first)/2;
            InputIterator middle = first+dist;
            if(middle > end) return;
        
            int max = end - middle;
            for(int i = 0; i < max; ++i)
                if(!comp(*(first+dist-1-i), *(middle+i)))
                    std::swap(*(first+dist-1-i), *(middle+i));
        }
        static void merge(InputIterator first, InputIterator last, InputIterator end, Compare comp){
            InputIterator middle = first+(last-first)/2;
            if(middle == first) return;
            compare(first, last, end, comp);
            merge(first, middle, std::min(middle,end), comp);
            merge(middle, last, end, comp);
        }
        static void sort(InputIterator first, InputIterator last, InputIterator end, Compare comp){
            InputIterator middle = first+(last-first)/2;
            if(middle == first) return;
            sort(first, middle, std::min(middle,end), comp);
            sort(middle, last, end, comp);

            compare_crossover(first, last, end, comp);
            merge(first, middle, std::min(middle,end), comp);
            merge(middle, last, end, comp);
        }
    };

    template<class InputIterator, class Compare>
    class bitonic_sort {
    public:
        typedef typename InputIterator::container_type container_type;
        typedef block_tuple_iterator<container_type, container_type> blocked_tuple_iterator;
        typedef block_iterator<container_type> blocked_iterator;
        typedef typename blocked_iterator::block_type block_type;
        typedef typename block_type::iterator block_type_iterator;
        static constexpr int ib = blocked_iterator::ib;

        static void compare_impl(block_type_iterator top_first, block_type_iterator top_last, block_type_iterator bottom_first, Compare comp){
            while(top_first != top_last){
                if(!comp(*top_first, *bottom_first))
                    std::swap(*top_first, *bottom_first);
                top_first++; bottom_first++;
            }
        }
        static void compare_crossover_impl(block_type_iterator bottom_first, block_type_iterator bottom_last, block_type_iterator top_first, Compare comp){
            while(bottom_first != bottom_last){
                if(!comp(*top_first, *bottom_first))
                    std::swap(*top_first, *bottom_first);
                top_first--; bottom_first++; 
            }
        }
        static void compare(InputIterator first, InputIterator last, InputIterator end, Compare comp){
            InputIterator middle = first+(last-first)/2;
            if(middle > end) return;

            for(blocked_tuple_iterator bit(first,middle,end-middle); bit != first+(end-middle); ++bit)
                if(&bit.template locate<0>() == &bit.template locate<1>())
                    ambient::async([comp](block_type& block, size_t first1, size_t second1, size_t first2){
                                       compare_impl(block.begin()+first1, block.begin()+second1, block.begin()+first2, comp);
                                   }, bit.template locate<0>(), bit.first[0], bit.second[0], bit.first[1]);
                else
                    ambient::async([comp](block_type& block1, size_t first1, size_t second1, block_type& block2, size_t first2){
                                       compare_impl(block1.begin()+first1, block1.begin()+second1, block2.begin()+first2, comp);
                                   }, bit.template locate<0>(), bit.first[0], bit.second[0], bit.template locate<1>(), bit.first[1]);
        }
        static void compare_crossover(InputIterator first, InputIterator last, InputIterator end, Compare comp){
            InputIterator middle = first+(last-first)/2;
            if(middle > end) return;

            size_t position_top = middle - first.get_container().begin() - 1;
            size_t position_bottom = middle - first.get_container().begin();
            size_t limit = end - first.get_container().begin();

            while(position_bottom != limit){
                size_t step = std::min(std::min(position_top - ib*((size_t)position_top/ib) + 1, 
                                                ib*__a_ceil((position_bottom+1)/ib) - position_bottom),
                                       limit-position_bottom);
                
                size_t bottom_first = position_bottom % ib;
                size_t bottom_second = bottom_first + step;
                
                size_t top_first = position_top % ib;
                size_t top_second = top_first - step;
                
                block_type& top = first.get_container().locate(position_top);
                block_type& bottom = first.get_container().locate(position_bottom);
                
                if(&top == &bottom)
                    ambient::async([comp](block_type& block, size_t first1, size_t second1, size_t first2){
                                       compare_crossover_impl(block.begin()+first1, block.begin()+second1, block.begin()+first2, comp);
                                   }, bottom, bottom_first, bottom_second, top_first);
                else
                    ambient::async([comp](block_type& block1, size_t first1, size_t second1, block_type& block2, size_t first2){
                                       compare_crossover_impl(block1.begin()+first1, block1.begin()+second1, block2.begin()+first2, comp);
                                   }, bottom, bottom_first, bottom_second, top, top_first);

                position_bottom += step;
                position_top -= step;
            }
        }
        static void merge(InputIterator first, InputIterator last, InputIterator end, Compare comp){
            if(is_same_block(first,end)){ 
                blocked_iterator bit(first,end);
                size_t last_ = bit.first + (last-first);
                ambient::async([comp](block_type& b, size_t first, size_t last, size_t end){
                    bitonic_sort_inblock<block_type_iterator,Compare>::merge(b.begin()+first, b.begin()+last, b.begin()+end, comp);
                }, *bit, bit.first, last_, bit.second);
                return; 
            }
            InputIterator middle = first+(last-first)/2;
            compare(first, last, end, comp);
            merge(first, middle, std::min(middle,end), comp);
            merge(middle, last, end, comp);
        }
        static void sort(InputIterator first, InputIterator last, InputIterator end, Compare comp){
            if(is_same_block(first,end)){
                blocked_iterator bit(first,end);
                size_t last_ = bit.first + (last-first);
                ambient::async([comp](block_type& b, size_t first, size_t last, size_t end){
                    bitonic_sort_inblock<block_type_iterator,Compare>::sort(b.begin()+first, b.begin()+last, b.begin()+end, comp);
                }, *bit, bit.first, last_, bit.second);
                return;
            }
            InputIterator middle = first+(last-first)/2;
            sort(first, middle, std::min(middle,end), comp);
            sort(middle, last, end, comp);

            compare_crossover(first, last, end, comp);
            merge(first, middle, std::min(middle,end), comp);
            merge(middle, last, end, comp);
        }
        static bool is_same_block(InputIterator first, InputIterator last){
            return (&*blocked_iterator(first,first+1) == &*blocked_iterator(last-1,last));
        }
    };

} }

#endif
